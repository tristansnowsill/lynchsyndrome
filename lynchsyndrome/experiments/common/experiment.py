from __future__ import annotations

import itertools
import logging
from os import getenv
from typing import Any, Callable, Iterable, List, Mapping, Optional, Tuple, TypeVar
from uuid import UUID, uuid4

import numpy.random
import pandas
import simpy
from dotenv import load_dotenv
from injector import Injector, ProviderOf, inject
from tqdm import tqdm

from lynchsyndrome.individual import Individual
from lynchsyndrome.experiments.common.competing_options import Pathway
from lynchsyndrome.experiments.common.parameters.sources import ParameterSource
from lynchsyndrome.experiments.common.config.providers import providers as common_providers

    
def setup(additional_providers: Optional[List] = []) -> Injector:
    load_dotenv()
    _setup_logging()
    return Injector(common_providers + additional_providers)

InterimResult = TypeVar('InterimResult')


class Experiment:
    @inject
    def __init__(
        self,
        param_source: ParameterSource,
        rng: numpy.random.Generator,
        env_provider: ProviderOf[simpy.Environment]
    ):
        self.param_source = param_source
        self.rng = rng
        self.env_provider = env_provider

        self.population = self._undefined_population
        self.n_psa = 1
        self.competing_options: dict[UUID, Pathway] = dict()
        self.events_reports: dict[str, Callable[[pandas.DataFrame], Any]] = dict()
        self.events_reports_requiring_params: dict[str, Tuple[Callable[[pandas.DataFrame, pandas.Series, Mapping[str, Any]], InterimResult], Callable[[Iterable[Tuple[UUID, InterimResult]]], Any]]] = dict()
        self.params_reports: dict[str, Callable[[pandas.DataFrame], Any]] = dict()
        self.events_and_params_reports: dict[str, Callable[[pandas.DataFrame, pandas.DataFrame], Any]] = dict()
    
    def _undefined_population(
        self,
        env: simpy.Environment,
        init_rng: numpy.random.Generator,
        sim_rng: numpy.random.Generator,
        params: Mapping[str, Any]
    ) -> List[Individual]:
        raise RuntimeError("The population for the experiment has not been set with set_population()")
    
    def set_population(
        self,
        population: Callable[[simpy.Environment, numpy.random.Generator, numpy.random.Generator, Mapping[str, Any]], List[Individual]]
    ) -> Experiment:
        """Provide the callback to create the population
        
        :param population: The callback which will be called with a
            ``simpy.Environment``, two ``numpy.random.Generator`` (the first of
            which is used for initialising the population and the second of
            which is used for subsequent simulation), and a parameter set

        The use of two (potentially different) ``numpy.random.Generator``
        makes it possible to have the same population mirrored across multiple
        simulations, but for the subsequent simulations to diverge (even if
        the same ``Pathway`` are used).
        """
        self.population = population
        return self
    
    def set_psa_samples(self, n: int) -> Experiment:
        self.n_psa = n
        return self
    
    def add_competing_option(self, pathway: Pathway) -> Experiment:
        self.competing_options[uuid4()] = pathway
        return self
    
    def add_events_report(self, key: str, callback: Callable[[pandas.DataFrame], Any]) -> Experiment:
        """Register a callback to create a Report based on the event traces

        The events will be provided in a ``pandas.DataFrame``.

        The index for this DataFrame will be a MultiIndex with the keys
        (pathway_uuid, params_uuid, individual_uuid, record_id). The first three
        of these are all UUIDs, while record_id is (though not guaranteed to be)
        a simple counter starting at 0. The columns for this DataFrame are time,
        event, and metadata.

        NOTE: The caller is responsible for making sure the key does not clash
        with keys for any other reports (including those registered using
        ``add_params_report`` and ``add_events_and_params_report``)
        """
        self.events_reports[key] = callback
        return self
    
    def add_events_report_requiring_params(
        self,
        key: str,
        cb_process: Callable[[pandas.DataFrame, pandas.Series, Mapping[str, Any]], InterimResult],
        cb_aggregate: Callable[[Iterable[Tuple[UUID, InterimResult]]], Any]
    ) -> Experiment:
        """Register callbacks to create a Report based on the event traces
        where the Report is assembled from ``InterimResult`` for each set of
        parameter values

        For each set of parameter values the callback `cb_process` will be
        called with the event traces generated by simulations using that set
        of parameter values and the ``Individual``s simulated. The event
        traces will take the form of a ``pandas.DataFrame`` which is as that
        described in ``add_events_report`` except params_uuid is not included
        in the MultiIndex. The :py:class:`Individual`s are supplied as a
        ``pandas.Series`` with the MultiIndex (pathway_uuid, individual_uuid).
        
        The callback `cb_process` can return a value of any type. Once all
        parameter sets have been processed, the callback `cb_aggregate` will
        be called and will be passed an Iterable of Tuple of params_uuid and
        the interim results calculated using `cb_process`.

        NOTE: The caller is responsible for making sure the key does not clash
        with keys for any other reports (including those registered using
        other methods)
        """
        self.events_reports_requiring_params[key] = (cb_process, cb_aggregate)
        return self
    
    def add_params_report(self, key: str, callback: Callable[[pandas.DataFrame], Any]) -> Experiment:
        """Register a callback to create a Report based on parameter values

        The parameters will be provided in a ``pandas.DataFrame``.

        The index for this DataFrame will be a UUID which is generated for each
        parameter set and each column will give the value for a parameter. Note
        that non-scalar parameters will be nested, so that they do not span
        multiple columns.

        NOTE: The caller is responsible for making sure the key does not clash
        with keys for any other reports (including those registered using
        ``add_events_report`` and ``add_events_and_params_report``)
        """
        self.params_reports[key] = callback
        return self
    
    def add_events_and_params_report(self, key: str, callback: Callable[[pandas.DataFrame, pandas.DataFrame], Any]) -> Experiment:
        """Register a callback to create a Report based on events and parameter values

        NOTE: The caller is responsible for making sure the key does not clash
        with keys for any other reports (including those registered using
        ``add_events_report`` and ``add_params_report``)
        """
        self.events_and_params_reports[key] = callback
        return self
    
    def get_competing_options(self) -> pandas.Series:
        """Return the competing option descriptions indexed by their UUIDs
        
        Internally ``Experiment`` uses UUIDs when processing the competing
        options so that it is not necessary for the competing options to have
        unique descriptions, or descriptions at all. But those UUIDs are not
        necessarily useful for the user.

        This method returns a series of the competing option descriptions
        which can be helpful for joining with other reports.
        """
        return pandas.Series(
            (p.description for p in self.competing_options.values()),
            index=pandas.Index(self.competing_options.keys())
        )
    
    
    def run(self) -> dict[str, Any]:

        if self.n_psa < 40:
            logging.warn("The number of parameter set samples is VERY low (%d). Results are very unlikely to be reliable.", self.n_psa)
        elif self.n_psa < 500:
            logging.warn("The number of parameter set samples is low (%d). Caution is advised.", self.n_psa)

        event_trace_cols = pandas.Index(['time', 'event', 'metadata'])

        # DataFrame to hold all (requested) parameters
        all_param_keys = self.param_source.keys()
        all_params = pandas.DataFrame(columns=all_param_keys)

        # DataFrame to hold all event traces
        all_event_traces = pandas.DataFrame(columns=event_trace_cols)

        # Mapping to hold InterimResults
        interim_results: dict[str, List[Tuple[UUID, InterimResult]]] = dict()
        for key in self.events_reports_requiring_params.keys():
            interim_results[key] = list()
        
        # The `Individual`s simulated for each set of parameters are stored in
        # a pandas.Series with the MultiIndex (pathway_uuid, individual_uuid)
        # and the name 'individual'
        params_individuals: dict[UUID, pandas.Series] = dict()

        # The event traces simulated for each set of parameters are stored in
        # a pandas.DataFrame with the MultiIndex
        # (pathway_uuid, individual_uuid, record_id) and the column names
        # time, event and metadata
        params_event_traces: dict[UUID, pandas.DataFrame] = dict()

        bar = None
        bar_spec = getenv('PROGRESS_BAR', 'off')
        if bar_spec == 'psa':
            bar = tqdm(total = self.n_psa)
        elif bar_spec == 'strategy':
            bar = tqdm(total = self.n_psa * (len(self.competing_options) + 6))

        for params in itertools.islice(self.param_source, self.n_psa):

            params_uuid = uuid4()

            if len(self.params_reports) > 0 or len(self.events_and_params_reports) > 0:
                these_params = dict()
                for pk in all_param_keys:
                    if isinstance(params[pk], float):
                        these_params[pk] = params[pk]
                    else:
                        these_params[pk] = [params[pk]]
                these_params_df = pandas.DataFrame(these_params, index=[params_uuid])
                all_params = pandas.concat((all_params, these_params_df), ignore_index=False)

            dict_params_individuals = dict()
            dict_params_event_traces = dict()

            # When we generate the populations we want to start from the same
            # random number generator state
            seed_sequence = numpy.random.SeedSequence(self.rng.bit_generator.random_raw())

            pathway_env = dict()
            pathway_pop = dict()
            for pathway_uuid, pathway in self.competing_options.items():

                replicable_rng = numpy.random.default_rng(seed_sequence)

                env = self.env_provider.get()
                pathway_env[pathway_uuid] = env

                population = self.population(env, replicable_rng, self.rng, params)
                pathway_pop[pathway_uuid] = population
            
                for individual in population:
                    env.process(individual.run())
                    for _, interventions in pathway.elements.items():
                        for intervention in interventions:
                            env.process(intervention.run(env, self.rng, params, individual))

                env.run(until=params['analysis.time_horizon']+1e-3)

                dict_params_individuals[pathway_uuid] = pandas.Series(
                    population,
                    index=[individual.uuid for individual in population],
                    name='individual'
                )
                dict_params_event_traces[pathway_uuid] = pandas.concat(
                    (individual.events() for individual in population),
                    axis=0,
                    keys=(individual.uuid for individual in population)
                )

                if bar_spec == 'strategy':
                    bar.update(1)

            # Add individuals
            params_individuals[params_uuid] = pandas.concat(dict_params_individuals, axis=0)
            params_individuals[params_uuid].index.rename(['pathway_uuid', 'individual_uuid'], inplace=True)

            # Add event traces
            params_event_traces[params_uuid] = pandas.concat(dict_params_event_traces, axis=0)
            params_event_traces[params_uuid].index.rename(['pathway_uuid', 'individual_uuid', 'record_id'], inplace=True)
            
            # Run callbacks to get InterimResult
            for key, (cb_process, _) in self.events_reports_requiring_params.items():
                interim_results[key].append((params_uuid, cb_process(params_event_traces[params_uuid], params_individuals[params_uuid], params)))
            
            if bar_spec == 'psa':
                bar.update(1)
            elif bar_spec == 'strategy':
                bar.update(6)

        if bar_spec != 'off':
            bar.close()

        # Run reports
        reports: dict[str, Any] = dict()

        all_event_traces = pandas.concat(params_event_traces, axis=0)
        all_event_traces.index = (
            all_event_traces.index
                .rename(['params_uuid', 'pathway_uuid', 'individual_uuid', 'record_id'])
                .reorder_levels(['pathway_uuid', 'params_uuid', 'individual_uuid', 'record_id'])
        )

        for key, callback in self.events_reports.items():
            reports[key] = callback(all_event_traces)
        
        for key, callback in self.params_reports.items():
            reports[key] = callback(all_params)
        
        for key, callback in self.events_and_params_reports.items():
            reports[key] = callback(all_event_traces, all_params)
        
        for key, (_, cb_aggregate) in self.events_reports_requiring_params.items():
            reports[key] = cb_aggregate(interim_results[key])
        
        return reports

        # event_traces = [individual.events() for individual in population]
        # costing = Costing(params)
        # benefits = Benefits(params, LinearIndexOverallUtility(), HSEBaselineUtility())
        # event_costs = [costing.event_costs(events, individual) for events, individual in zip(event_traces, population)]
        # running_costs = [costing.running_costs(events, individual) for events, individual in zip(event_traces, population)]
        # life_years = [benefits.life_years(events) for events in event_traces]
        # qalys = [benefits.qalys(population[i], event_traces[i]) for i in range(len(population))]

        # # Concatenate...
        # event_traces_df  = pandas.concat(event_traces, axis=0, keys=[i.uuid for i in population])
        # event_costs_df   = pandas.concat(event_costs, axis=0, keys=[i.uuid for i in population])
        # running_costs_df = pandas.concat(running_costs, axis=0, keys=[i.uuid for i in population])
        # total_costs_df   = event_costs_df + running_costs_df
        # life_years_df    = pandas.concat(life_years, axis=0, keys=[i.uuid for i in population])
        # qalys_df         = pandas.concat(qalys, axis=0, keys=[i.uuid for i in population])

        # import seaborn as sns

        # patient_costs = total_costs_df.groupby(level=0).sum()
        # patient_qalys = qalys_df.groupby(level=0).sum()
        # plot = sns.jointplot(x=patient_qalys, y=patient_costs)
        # # plot = sns.displot(total_costs_df.groupby(level=0).sum(), binwidth=100)
        # plot.savefig("patient_qalys_costs.png")

        # print("Event traces:")
        # print(event_traces_df)

        # print("Event costs:")
        # print(event_costs_df)

        # print("Running costs:")
        # print(running_costs_df)

        # print("Total costs:")
        # print(total_costs_df)

        # print(total_costs_df.groupby(level=[0]).sum().mean())


def _setup_logging():
    log_format = '%(asctime)s - %(levelname)s - %(message)s'
    log_datefmt = '%Y-%m-%d %H:%M:%S'
    # Check the log channel
    log_channel = getenv('LOG_CHANNEL')
    if log_channel is None or log_channel == 'stderr':
        # Print to stderr at the specified level
        log_level = getenv('LOG_LEVEL', 'warn')
        log_level = logging.getLevelName(log_level.upper())
        logging.basicConfig(format=log_format, datefmt=log_datefmt, level=log_level)
    elif log_channel == 'single':
        raise NotImplementedError()
    elif log_channel == 'unique':
        raise NotImplementedError()

